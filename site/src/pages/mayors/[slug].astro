---
// ABOUTME: Mayor profile page showing mayor stats and all their cities.
// ABOUTME: Resolves mayor from slug URL (name + short code), then fetches profile from API.
import Base from '../../layouts/Base.astro';
import CityCard from '../../components/CityCard.astro';
import { apiFetch } from '../../lib/api';

const { slug } = Astro.params;
const code = slug!.split('-').pop()!;
const mayor = await apiFetch<any>(`/v1/mayors/resolve/${code}`);
---
<Base title={mayor.name}>
  <h1>{mayor.name}</h1>
  <div class="mayor-stats">
    <div class="stat">
      <span class="stat-value">{mayor.stats.total_cities}</span>
      <span class="stat-label">Cities Built</span>
    </div>
    <div class="stat">
      <span class="stat-value">{(mayor.stats.best_population || 0).toLocaleString()}</span>
      <span class="stat-label">Best Population</span>
    </div>
    <div class="stat">
      <span class="stat-value">{mayor.stats.best_score || 0}</span>
      <span class="stat-label">Best Score</span>
    </div>
  </div>

  <h2>Cities</h2>
  {mayor.cities.length === 0 ? (
    <p class="empty">No cities yet.</p>
  ) : (
    <div class="city-grid">
      {mayor.cities.map((city: any) => (
        <CityCard {...city} mayor={mayor.name} />
      ))}
    </div>
  )}
</Base>

<script>
  import { loadSpriteSheet, TILE_SIZE, tileIdFromRaw, spriteCoords } from '../../lib/sprites';

  let spriteSheet: HTMLImageElement | null = null;

  async function renderThumbnail(el: HTMLElement) {
    const cityId = el.dataset.cityId;
    const apiBase = el.dataset.apiBase;
    if (!cityId || !apiBase) return;

    const [sheet, mapRes] = await Promise.all([
      spriteSheet ? Promise.resolve(spriteSheet) : loadSpriteSheet('/tiles.png').then(img => { spriteSheet = img; return img; }),
      fetch(`${apiBase}/v1/cities/${cityId}/map`).then(r => r.json()),
    ]);

    const canvas = document.createElement('canvas');
    const mapWidth = mapRes.width;
    const mapHeight = mapRes.height;

    const offscreen = document.createElement('canvas');
    offscreen.width = mapWidth * TILE_SIZE;
    offscreen.height = mapHeight * TILE_SIZE;
    const offCtx = offscreen.getContext('2d')!;
    for (let y = 0; y < mapHeight; y++) {
      for (let x = 0; x < mapWidth; x++) {
        const raw = mapRes.tiles[y * mapWidth + x];
        const tileId = tileIdFromRaw(raw);
        const { sx, sy } = spriteCoords(tileId);
        offCtx.drawImage(sheet, sx, sy, TILE_SIZE, TILE_SIZE, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      }
    }

    canvas.width = el.clientWidth * 2;
    canvas.height = el.clientHeight * 2;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    const ctx = canvas.getContext('2d')!;
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(offscreen, 0, 0, canvas.width, canvas.height);
    el.appendChild(canvas);
  }

  const observer = new IntersectionObserver((entries) => {
    for (const entry of entries) {
      if (entry.isIntersecting) {
        observer.unobserve(entry.target);
        renderThumbnail(entry.target as HTMLElement);
      }
    }
  }, { rootMargin: '200px' });

  document.querySelectorAll('.card-thumb').forEach(el => observer.observe(el));
</script>

<style>
.mayor-stats {
  display: flex;
  gap: 1rem;
  margin: 1.5rem 0;
  flex-wrap: wrap;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: 3px;
  padding: 1rem;
  box-shadow: 3px 3px 0 var(--shadow);
}
.stat {
  display: flex;
  flex-direction: column;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 2px;
  padding: 0.5rem 1rem;
}
.stat-value { font-size: 1.5rem; font-weight: 700; }
.stat-label { font-family: var(--pixel-font); color: var(--text-muted); font-size: 0.4rem; text-transform: uppercase; letter-spacing: 1px; margin-top: 0.15rem; }
h2 { margin-bottom: 1rem; }
.city-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 1rem; }
.empty { color: var(--text-muted); }
@media (max-width: 480px) {
  .mayor-stats { gap: 0.75rem; padding: 0.75rem; }
  .stat-value { font-size: 1.25rem; }
}
</style>
