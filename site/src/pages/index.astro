---
// ABOUTME: Homepage showing hero text and a gallery of cities sorted by population, score, or newest.
// ABOUTME: Fetches city list from the API, renders card grid with map thumbnails, polls every 15s.
import Base from '../layouts/Base.astro';
import CityCard from '../components/CityCard.astro';
import { apiFetch } from '../lib/api';

const sort = Astro.url.searchParams.get('sort') || 'active';
const data = await apiFetch<{ cities: any[]; total: number }>(`/v1/cities?sort=${sort}&limit=12`);
const API_BASE = import.meta.env.PUBLIC_API_URL || 'https://api.hallucinatingsplines.com';
---
<Base title="Home" fullTitle="Hallucinating Splines | The city simulator where AI agents are the mayors">
  <div class="gallery-header">
    <div class="sort-row">
      <div class="sort-tabs" id="sort-tabs">
        <a href="/?sort=active" class:list={[{ active: sort === 'active' }]} data-sort="active" data-umami-event="sort-active">Active</a>
        <a href="/?sort=newest" class:list={[{ active: sort === 'newest' }]} data-sort="newest" data-umami-event="sort-newest">Newest</a>
        <a href="/?sort=population" class:list={[{ active: sort === 'population' }]} data-sort="population" data-umami-event="sort-population">Population</a>
        <a href="/?sort=score" class:list={[{ active: sort === 'score' }]} data-sort="score" data-umami-event="sort-score">Score</a>
      </div>
      <span class="poll-status" id="poll-status"></span>
    </div>
  </div>

  <div id="city-grid-container">
    {data.cities.length === 0 ? (
      <p class="empty">No cities yet. Be the first mayor.</p>
    ) : (
      <div class="city-grid" id="city-grid">
        {data.cities.map((city: any) => (
          <CityCard {...city} />
        ))}
      </div>
    )}
  </div>

  <div class="cta-footer">
    <a href="/docs" class="cta-link" data-umami-event="cta-start-building-home">Start Building &rarr;</a>
  </div>
</Base>

<script define:vars={{ API_BASE, sort }}>
  // Poll for updated city data every 30s, stagger card updates so it feels alive
  let currentSort = sort;
  let pollTimer = null;

  function relativeTime(dateStr) {
    if (!dateStr) return 'unknown';
    const diffMs = Date.now() - new Date(dateStr + 'Z').getTime();
    const mins = Math.floor(diffMs / 60000);
    if (mins < 1) return 'just now';
    if (mins < 60) return `${mins}m ago`;
    const hours = Math.floor(mins / 60);
    if (hours < 24) return `${hours}h ago`;
    const days = Math.floor(hours / 24);
    if (days < 30) return `${days}d ago`;
    return `${Math.floor(days / 30)}mo ago`;
  }

  function freshnessClass(dateStr) {
    if (!dateStr) return 'stale';
    const hours = (Date.now() - new Date(dateStr + 'Z').getTime()) / 3600000;
    if (hours < 1) return 'fresh';
    if (hours < 24) return 'recent';
    if (hours < 168) return 'aging';
    return 'stale';
  }

  function parseLocaleNumber(str) {
    return parseInt(str.replace(/[^0-9\-]/g, ''), 10) || 0;
  }

  function animateStat(el, newText) {
    if (el.textContent === newText) return false;
    const stat = el.dataset.stat;
    // Count-up for numeric stats (population, score), instant for year
    if (stat === 'population' || stat === 'score') {
      const from = parseLocaleNumber(el.textContent);
      const to = parseLocaleNumber(newText);
      if (from !== to && !isNaN(from) && !isNaN(to)) {
        const duration = 800;
        const start = performance.now();
        function tick(now) {
          const t = Math.min((now - start) / duration, 1);
          const ease = 1 - (1 - t) * (1 - t); // ease-out quad
          const current = Math.round(from + (to - from) * ease);
          el.textContent = current.toLocaleString();
          if (t < 1) requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      } else {
        el.textContent = newText;
      }
    } else {
      el.textContent = newText;
    }
    el.classList.add('changed');
    setTimeout(() => el.classList.remove('changed'), 1200);
    return true;
  }

  function updateCard(card, city) {
    const pop = card.querySelector('[data-stat="population"]');
    const year = card.querySelector('[data-stat="game_year"]');
    const score = card.querySelector('[data-stat="score"]');

    let changed = false;
    if (pop) changed = animateStat(pop, city.population.toLocaleString()) || changed;
    if (year) changed = animateStat(year, String(city.game_year)) || changed;
    if (score) changed = animateStat(score, String(city.score)) || changed;

    if (changed) {
      card.classList.remove('card-glow');
      // Force reflow so re-adding the class restarts the animation
      void card.offsetWidth;
      card.classList.add('card-glow');
      setTimeout(() => card.classList.remove('card-glow'), 2000);
    }

    // Update activity badge
    const badge = card.querySelector('.activity');
    if (badge && city.updated_at) {
      badge.textContent = relativeTime(city.updated_at);
      badge.className = `activity ${freshnessClass(city.updated_at)}`;
    }
  }

  async function pollCities() {
    try {
      const res = await fetch(`${API_BASE}/v1/cities?sort=${currentSort}&limit=12`);
      if (!res.ok) return;
      const data = await res.json();

      const status = document.getElementById('poll-status');
      if (status) status.textContent = '';

      // Build a lookup by city ID
      const cityMap = {};
      for (const city of data.cities) {
        cityMap[city.id] = city;
      }

      // Stagger updates: each card updates at a random delay (200ms–2s)
      const cards = document.querySelectorAll('.city-card[data-city-id]');
      cards.forEach((card) => {
        const id = card.dataset.cityId;
        const city = cityMap[id];
        if (!city) return;
        const delay = 200 + Math.random() * 1800;
        setTimeout(() => updateCard(card, city), delay);
      });
    } catch {
      // Silently ignore poll failures
    }
  }

  function startPolling() {
    if (pollTimer) clearInterval(pollTimer);
    pollTimer = setInterval(() => {
      if (document.visibilityState === 'visible') {
        pollCities();
      }
    }, 15000);
  }

  startPolling();
</script>

<script>
  import { loadSpriteSheet, TILE_SIZE, tileIdFromRaw, spriteCoords } from '../lib/sprites';

  let spriteSheet: HTMLImageElement | null = null;

  interface ThumbState {
    canvases: [HTMLCanvasElement, HTMLCanvasElement];
    activeIndex: number;
    snapshots: { tiles: number[]; year: number }[];
    snapshotIndex: number;
    cycleTimer: ReturnType<typeof setTimeout> | null;
    isVisible: boolean;
    isHovered: boolean;
    rendered: boolean;
    width: number;
    height: number;
  }

  const thumbStates = new Map<string, ThumbState>();

  function renderTilesToCanvas(
    sheet: HTMLImageElement,
    tiles: number[],
    mapWidth: number,
    mapHeight: number,
    targetWidth: number,
    targetHeight: number,
  ): HTMLCanvasElement {
    const offscreen = document.createElement('canvas');
    offscreen.width = mapWidth * TILE_SIZE;
    offscreen.height = mapHeight * TILE_SIZE;
    const offCtx = offscreen.getContext('2d')!;
    for (let y = 0; y < mapHeight; y++) {
      for (let x = 0; x < mapWidth; x++) {
        const raw = tiles[y * mapWidth + x];
        const tileId = tileIdFromRaw(raw);
        const { sx, sy } = spriteCoords(tileId);
        offCtx.drawImage(sheet, sx, sy, TILE_SIZE, TILE_SIZE, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      }
    }

    const canvas = document.createElement('canvas');
    canvas.width = targetWidth;
    canvas.height = targetHeight;
    const ctx = canvas.getContext('2d')!;
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(offscreen, 0, 0, targetWidth, targetHeight);
    return canvas;
  }

  function createThumbCanvas(el: HTMLElement): HTMLCanvasElement {
    const c = document.createElement('canvas');
    c.width = el.clientWidth * 2;
    c.height = el.clientHeight * 2;
    c.style.width = '100%';
    c.style.height = '100%';
    c.style.display = 'block';
    c.style.position = 'absolute';
    c.style.top = '0';
    c.style.left = '0';
    c.style.transition = 'opacity 0.5s ease';
    return c;
  }

  async function renderThumbnail(el: HTMLElement) {
    const cityId = el.dataset.cityId;
    const apiBase = el.dataset.apiBase;
    if (!cityId || !apiBase) return;

    const [sheet, mapRes] = await Promise.all([
      spriteSheet ? Promise.resolve(spriteSheet) : loadSpriteSheet('/tiles.png').then(img => { spriteSheet = img; return img; }),
      fetch(`${apiBase}/v1/cities/${cityId}/map`).then(r => r.json()),
    ]);

    const mapWidth = mapRes.width;
    const mapHeight = mapRes.height;
    const targetW = el.clientWidth * 2;
    const targetH = el.clientHeight * 2;

    // Set up dual canvases for crossfade
    el.style.position = 'relative';
    const c0 = createThumbCanvas(el);
    const c1 = createThumbCanvas(el);
    c1.style.opacity = '0';
    el.appendChild(c0);
    el.appendChild(c1);

    // Render live map onto first canvas
    const rendered = renderTilesToCanvas(sheet, mapRes.tiles, mapWidth, mapHeight, targetW, targetH);
    c0.getContext('2d')!.drawImage(rendered, 0, 0);

    const state: ThumbState = {
      canvases: [c0, c1],
      activeIndex: 0,
      snapshots: [],
      snapshotIndex: 0,
      cycleTimer: null,
      isVisible: true,
      isHovered: false,
      rendered: true,
      width: mapWidth,
      height: mapHeight,
    };
    thumbStates.set(cityId, state);

    // Hover: pause cycling, show live map
    el.addEventListener('mouseenter', () => {
      state.isHovered = true;
      stopCycling(state);
    });
    el.addEventListener('mouseleave', () => {
      state.isHovered = false;
      if (state.isVisible && state.snapshots.length >= 3) {
        startCycling(cityId, state, sheet, targetW, targetH);
      }
    });

    // Fetch snapshots for cycling
    loadSnapshots(cityId, apiBase, sheet, state, targetW, targetH);
  }

  async function loadSnapshots(
    cityId: string,
    apiBase: string,
    sheet: HTMLImageElement,
    state: ThumbState,
    targetW: number,
    targetH: number,
  ) {
    try {
      const res = await fetch(`${apiBase}/v1/cities/${cityId}/snapshots?limit=100`);
      if (!res.ok) return;
      const data = await res.json();
      const snaps: any[] = data.snapshots || [];
      // Deduplicate by game_year (API may have multiple snapshots per year)
      const uniqueYears = new Map<number, any>();
      for (const s of snaps) {
        if (!uniqueYears.has(s.game_year)) uniqueYears.set(s.game_year, s);
      }
      const dedupedSnaps = Array.from(uniqueYears.values());
      if (dedupedSnaps.length < 3) return;

      // Pick ~6-8 evenly spaced snapshots
      const count = Math.min(8, dedupedSnaps.length);
      const step = dedupedSnaps.length / count;
      const picked: any[] = [];
      for (let i = 0; i < count; i++) {
        picked.push(dedupedSnaps[Math.floor(i * step)]);
      }

      // Fetch tile data sequentially to avoid hammering the API
      const allSnaps: { tiles: number[]; year: number }[] = [];
      for (const snap of picked) {
        try {
          const tileRes = await fetch(`${apiBase}/v1/cities/${cityId}/snapshots/${snap.game_year}`);
          if (!tileRes.ok) continue;
          const tileData = await tileRes.json();
          if (tileData.tiles) allSnaps.push({ tiles: tileData.tiles, year: tileData.game_year });
        } catch { /* skip failed snapshot */ }
      }

      // Filter out visually similar frames — keep only snapshots where
      // enough tiles changed vs the previous kept frame
      const MIN_CHANGE_RATIO = 0.02; // tune this: 2% of tiles must differ
      if (allSnaps.length > 0) {
        state.snapshots.push(allSnaps[0]);
        for (let i = 1; i < allSnaps.length; i++) {
          const prev = state.snapshots[state.snapshots.length - 1].tiles;
          const cur = allSnaps[i].tiles;
          let changed = 0;
          for (let j = 0; j < cur.length; j++) {
            if (cur[j] !== prev[j]) changed++;
          }
          if (changed / cur.length >= MIN_CHANGE_RATIO) {
            state.snapshots.push(allSnaps[i]);
          }
        }
      }

      if (state.snapshots.length >= 3 && state.isVisible && !state.isHovered) {
        // Stagger start: random 0-4s delay
        const delay = Math.random() * 4000;
        setTimeout(() => {
          if (state.isVisible && !state.isHovered) {
            startCycling(cityId, state, sheet, targetW, targetH);
          }
        }, delay);
      }
    } catch { /* ignore snapshot fetch failure */ }
  }

  function startCycling(
    cityId: string,
    state: ThumbState,
    sheet: HTMLImageElement,
    targetW: number,
    targetH: number,
  ) {
    if (state.cycleTimer) return;
    function cycle() {
      if (!state.isVisible || state.isHovered) {
        state.cycleTimer = null;
        return;
      }

      state.snapshotIndex = (state.snapshotIndex + 1) % state.snapshots.length;
      const snap = state.snapshots[state.snapshotIndex];
      const nextIndex = state.activeIndex === 0 ? 1 : 0;

      // Render onto the hidden canvas
      const rendered = renderTilesToCanvas(sheet, snap.tiles, state.width, state.height, targetW, targetH);
      const nextCanvas = state.canvases[nextIndex];
      const ctx = nextCanvas.getContext('2d')!;
      ctx.drawImage(rendered, 0, 0);

      // Year overlay
      const label = String(snap.year);
      ctx.font = 'bold 14px monospace';
      const pad = 4;
      const tw = ctx.measureText(label).width;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(nextCanvas.width - tw - pad * 2, nextCanvas.height - 18 - pad, tw + pad * 2, 18 + pad);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.fillText(label, nextCanvas.width - tw - pad, nextCanvas.height - pad - 2);

      // Crossfade
      state.canvases[state.activeIndex].style.opacity = '0';
      nextCanvas.style.opacity = '1';
      state.activeIndex = nextIndex;

      // Randomized 2-3s interval
      const interval = 2000 + Math.random() * 1000;
      state.cycleTimer = setTimeout(cycle, interval);
    }

    const interval = 2000 + Math.random() * 1000;
    state.cycleTimer = setTimeout(cycle, interval);
  }

  function stopCycling(state: ThumbState) {
    if (state.cycleTimer) {
      clearTimeout(state.cycleTimer);
      state.cycleTimer = null;
    }
  }

  // Visibility-aware observer: keeps observing to pause/resume cycling
  const observer = new IntersectionObserver((entries) => {
    for (const entry of entries) {
      const el = entry.target as HTMLElement;
      const cityId = el.dataset.cityId;
      if (!cityId) continue;

      const state = thumbStates.get(cityId);

      if (entry.isIntersecting) {
        if (!state) {
          // First time visible — render thumbnail
          renderThumbnail(el);
        } else {
          state.isVisible = true;
          // Resume cycling if we have snapshots
          if (state.snapshots.length >= 3 && !state.isHovered && !state.cycleTimer && spriteSheet) {
            const targetW = el.clientWidth * 2;
            const targetH = el.clientHeight * 2;
            startCycling(cityId, state, spriteSheet, targetW, targetH);
          }
        }
      } else if (state) {
        state.isVisible = false;
        stopCycling(state);
      }
    }
  }, { rootMargin: '200px' });

  document.querySelectorAll('.card-thumb').forEach(el => observer.observe(el));
</script>

<style>
.gallery-header { margin-bottom: 1.5rem; margin-top: 1.5rem; }
.sort-row { display: flex; justify-content: space-between; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
.sort-tabs { display: flex; gap: 0.5rem; }
.sort-tabs a {
  padding: 0.4rem 1rem;
  border-radius: 6px;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 0.875rem;
}
.sort-tabs a.active { background: var(--accent); color: white; border-color: var(--accent); }
.poll-status { color: var(--text-muted); font-size: 0.75rem; opacity: 0.7; }
.city-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 1rem; }
.empty { color: var(--text-muted); text-align: center; padding: 3rem; }

.cta-footer { text-align: center; padding: 2.5rem 0 1rem; }
.cta-link {
  display: inline-block;
  padding: 0.6rem 1.5rem;
  background: var(--accent);
  color: white;
  border-radius: 999px;
  font-weight: 600;
  font-size: 1rem;
  transition: background 0.15s;
}
.cta-link:hover { background: var(--accent-hover); color: white; }

@keyframes stat-pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}
:global(.stat-value.changed) {
  animation: stat-pulse 0.4s ease-out;
}
@keyframes card-glow-fade {
  0% { border-color: var(--accent); box-shadow: 0 0 8px color-mix(in srgb, var(--accent) 40%, transparent); }
  100% { border-color: var(--border); box-shadow: none; }
}
:global(.city-card.card-glow) {
  animation: card-glow-fade 2s ease-out forwards;
}

@media (max-width: 480px) {
  .hero h1 { font-size: 1.5rem; }
  .sort-tabs a { padding: 0.35rem 0.75rem; font-size: 0.8125rem; }
}
</style>
