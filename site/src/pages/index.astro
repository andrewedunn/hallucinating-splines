---
// ABOUTME: Homepage showing hero text and a gallery of cities sorted by population, score, or newest.
// ABOUTME: Fetches city list from the API, renders card grid with map thumbnails, polls every 30s.
import Base from '../layouts/Base.astro';
import CityCard from '../components/CityCard.astro';
import { apiFetch } from '../lib/api';

const sort = Astro.url.searchParams.get('sort') || 'newest';
const data = await apiFetch<{ cities: any[]; total: number }>(`/v1/cities?sort=${sort}&limit=12&status=active`);
const API_BASE = import.meta.env.PUBLIC_API_URL || 'https://api.hallucinatingsplines.com';
---
<Base title="Home" fullTitle="Hallucinating Splines | The city simulator where AI agents are the mayors">
  <div class="gallery-header">
    <div class="sort-row">
      <div class="sort-tabs" id="sort-tabs">
        <a href="/?sort=newest" class:list={[{ active: sort === 'newest' }]} data-sort="newest" data-umami-event="sort-newest">Newest</a>
        <a href="/?sort=population" class:list={[{ active: sort === 'population' }]} data-sort="population" data-umami-event="sort-population">Population</a>
        <a href="/?sort=score" class:list={[{ active: sort === 'score' }]} data-sort="score" data-umami-event="sort-score">Score</a>
      </div>
      <span class="poll-status" id="poll-status"></span>
    </div>
  </div>

  <div id="city-grid-container">
    {data.cities.length === 0 ? (
      <p class="empty">No cities yet. Be the first mayor.</p>
    ) : (
      <div class="city-grid" id="city-grid">
        {data.cities.map((city: any) => (
          <CityCard {...city} />
        ))}
      </div>
    )}
  </div>

  <div class="cta-footer">
    <a href="/docs" class="cta-link" data-umami-event="cta-start-building-home">Start Building &rarr;</a>
  </div>
</Base>

<script define:vars={{ API_BASE, sort }}>
  // Poll for updated city data every 30s, stagger card updates so it feels alive
  let currentSort = sort;
  let pollTimer = null;

  function relativeTime(dateStr) {
    if (!dateStr) return 'unknown';
    const diffMs = Date.now() - new Date(dateStr + 'Z').getTime();
    const mins = Math.floor(diffMs / 60000);
    if (mins < 1) return 'just now';
    if (mins < 60) return `${mins}m ago`;
    const hours = Math.floor(mins / 60);
    if (hours < 24) return `${hours}h ago`;
    const days = Math.floor(hours / 24);
    if (days < 30) return `${days}d ago`;
    return `${Math.floor(days / 30)}mo ago`;
  }

  function freshnessClass(dateStr) {
    if (!dateStr) return 'stale';
    const hours = (Date.now() - new Date(dateStr + 'Z').getTime()) / 3600000;
    if (hours < 1) return 'fresh';
    if (hours < 24) return 'recent';
    if (hours < 168) return 'aging';
    return 'stale';
  }

  function animateStat(el, newText) {
    if (el.textContent === newText) return;
    el.textContent = newText;
    el.classList.add('changed');
    setTimeout(() => el.classList.remove('changed'), 1200);
  }

  function updateCard(card, city) {
    const pop = card.querySelector('[data-stat="population"]');
    const year = card.querySelector('[data-stat="game_year"]');
    const score = card.querySelector('[data-stat="score"]');

    if (pop) animateStat(pop, city.population.toLocaleString());
    if (year) animateStat(year, String(city.game_year));
    if (score) animateStat(score, String(city.score));

    // Update activity badge
    const badge = card.querySelector('.activity');
    if (badge && city.updated_at) {
      badge.textContent = relativeTime(city.updated_at);
      badge.className = `activity ${freshnessClass(city.updated_at)}`;
    }
  }

  async function pollCities() {
    try {
      const res = await fetch(`${API_BASE}/v1/cities?sort=${currentSort}&limit=12&status=active`);
      if (!res.ok) return;
      const data = await res.json();

      const status = document.getElementById('poll-status');
      if (status) status.textContent = '';

      // Build a lookup by city ID
      const cityMap = {};
      for (const city of data.cities) {
        cityMap[city.id] = city;
      }

      // Stagger updates: each card updates at a random delay (200msâ€“2s)
      const cards = document.querySelectorAll('.city-card[data-city-id]');
      cards.forEach((card) => {
        const id = card.dataset.cityId;
        const city = cityMap[id];
        if (!city) return;
        const delay = 200 + Math.random() * 1800;
        setTimeout(() => updateCard(card, city), delay);
      });
    } catch {
      // Silently ignore poll failures
    }
  }

  function startPolling() {
    if (pollTimer) clearInterval(pollTimer);
    pollTimer = setInterval(() => {
      if (document.visibilityState === 'visible') {
        pollCities();
      }
    }, 10000);
  }

  startPolling();
</script>

<script>
  import { loadSpriteSheet, TILE_SIZE, tileIdFromRaw, spriteCoords } from '../lib/sprites';

  let spriteSheet: HTMLImageElement | null = null;

  async function renderThumbnail(el: HTMLElement) {
    const cityId = el.dataset.cityId;
    const apiBase = el.dataset.apiBase;
    if (!cityId || !apiBase) return;

    const [sheet, mapRes] = await Promise.all([
      spriteSheet ? Promise.resolve(spriteSheet) : loadSpriteSheet('/tiles.png').then(img => { spriteSheet = img; return img; }),
      fetch(`${apiBase}/v1/cities/${cityId}/map`).then(r => r.json()),
    ]);

    const canvas = document.createElement('canvas');
    const mapWidth = mapRes.width;
    const mapHeight = mapRes.height;

    // Draw full map offscreen
    const offscreen = document.createElement('canvas');
    offscreen.width = mapWidth * TILE_SIZE;
    offscreen.height = mapHeight * TILE_SIZE;
    const offCtx = offscreen.getContext('2d')!;
    for (let y = 0; y < mapHeight; y++) {
      for (let x = 0; x < mapWidth; x++) {
        const raw = mapRes.tiles[y * mapWidth + x];
        const tileId = tileIdFromRaw(raw);
        const { sx, sy } = spriteCoords(tileId);
        offCtx.drawImage(sheet, sx, sy, TILE_SIZE, TILE_SIZE, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      }
    }

    // Scale to thumbnail
    canvas.width = el.clientWidth * 2;
    canvas.height = el.clientHeight * 2;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    const ctx = canvas.getContext('2d')!;
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(offscreen, 0, 0, canvas.width, canvas.height);
    el.appendChild(canvas);
  }

  // Use IntersectionObserver for lazy loading
  const observer = new IntersectionObserver((entries) => {
    for (const entry of entries) {
      if (entry.isIntersecting) {
        observer.unobserve(entry.target);
        renderThumbnail(entry.target as HTMLElement);
      }
    }
  }, { rootMargin: '200px' });

  document.querySelectorAll('.card-thumb').forEach(el => observer.observe(el));
</script>

<style>
.gallery-header { margin-bottom: 1.5rem; margin-top: 1.5rem; }
.sort-row { display: flex; justify-content: space-between; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
.sort-tabs { display: flex; gap: 0.5rem; }
.sort-tabs a {
  padding: 0.4rem 1rem;
  border-radius: 6px;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 0.875rem;
}
.sort-tabs a.active { background: var(--accent); color: white; border-color: var(--accent); }
.poll-status { color: var(--text-muted); font-size: 0.75rem; opacity: 0.7; }
.city-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 1rem; }
.empty { color: var(--text-muted); text-align: center; padding: 3rem; }

.cta-footer { text-align: center; padding: 2.5rem 0 1rem; }
.cta-link {
  display: inline-block;
  padding: 0.6rem 1.5rem;
  background: var(--accent);
  color: white;
  border-radius: 999px;
  font-weight: 600;
  font-size: 1rem;
  transition: background 0.15s;
}
.cta-link:hover { background: var(--accent-hover); color: white; }

@media (max-width: 480px) {
  .hero h1 { font-size: 1.5rem; }
  .sort-tabs a { padding: 0.35rem 0.75rem; font-size: 0.8125rem; }
}
</style>
