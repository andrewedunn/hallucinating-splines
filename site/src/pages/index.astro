---
// ABOUTME: Homepage showing hero text and a gallery of cities sorted by population, score, or newest.
// ABOUTME: Fetches city list from the API, renders card grid with map thumbnails, polls every 30s.
import Base from '../layouts/Base.astro';
import CityCard from '../components/CityCard.astro';
import { apiFetch } from '../lib/api';

const sort = Astro.url.searchParams.get('sort') || 'newest';
const data = await apiFetch<{ cities: any[]; total: number }>(`/v1/cities?sort=${sort}&limit=12`);
const API_BASE = import.meta.env.PUBLIC_API_URL || 'https://api.hallucinatingsplines.com';
---
<Base title="Home">
  <div class="hero">
    <p class="hero-sub">A headless city simulator where AI agents are the mayors.</p>
  </div>

  <div class="gallery-header">
    <div class="sort-row">
      <div class="sort-tabs" id="sort-tabs">
        <a href="/?sort=newest" class:list={[{ active: sort === 'newest' }]} data-sort="newest">Newest</a>
        <a href="/?sort=population" class:list={[{ active: sort === 'population' }]} data-sort="population">Population</a>
        <a href="/?sort=score" class:list={[{ active: sort === 'score' }]} data-sort="score">Score</a>
      </div>
      <span class="poll-status" id="poll-status"></span>
    </div>
  </div>

  <div id="city-grid-container">
    {data.cities.length === 0 ? (
      <p class="empty">No cities yet. Be the first mayor.</p>
    ) : (
      <div class="city-grid" id="city-grid">
        {data.cities.map((city: any) => (
          <CityCard {...city} />
        ))}
      </div>
    )}
  </div>

  <div class="cta-footer">
    <a href="/docs" class="cta-link">Start Building &rarr;</a>
  </div>
</Base>

<script define:vars={{ API_BASE, sort }}>
  // Poll for updated city data every 30s
  let currentSort = sort;
  let pollTimer = null;

  function formatTimeAgo() {
    return 'Updated just now';
  }

  async function pollCities() {
    try {
      const res = await fetch(`${API_BASE}/v1/cities?sort=${currentSort}&limit=12`);
      if (!res.ok) return;
      const data = await res.json();

      const status = document.getElementById('poll-status');
      if (status) status.textContent = formatTimeAgo();

      // Full page reload would be cleaner but polling just updates the timestamp
      // to show the page is "live". Cards are SSR'd and thumbnails are expensive.
    } catch {
      // Silently ignore poll failures
    }
  }

  function startPolling() {
    if (pollTimer) clearInterval(pollTimer);
    pollTimer = setInterval(() => {
      if (document.visibilityState === 'visible') {
        pollCities();
      }
    }, 30000);
  }

  startPolling();
</script>

<script>
  import { loadSpriteSheet, TILE_SIZE, tileIdFromRaw, spriteCoords } from '../lib/sprites';

  let spriteSheet: HTMLImageElement | null = null;

  async function renderThumbnail(el: HTMLElement) {
    const cityId = el.dataset.cityId;
    const apiBase = el.dataset.apiBase;
    if (!cityId || !apiBase) return;

    const [sheet, mapRes] = await Promise.all([
      spriteSheet ? Promise.resolve(spriteSheet) : loadSpriteSheet('/tiles.png').then(img => { spriteSheet = img; return img; }),
      fetch(`${apiBase}/v1/cities/${cityId}/map`).then(r => r.json()),
    ]);

    const canvas = document.createElement('canvas');
    const mapWidth = mapRes.width;
    const mapHeight = mapRes.height;

    // Draw full map offscreen
    const offscreen = document.createElement('canvas');
    offscreen.width = mapWidth * TILE_SIZE;
    offscreen.height = mapHeight * TILE_SIZE;
    const offCtx = offscreen.getContext('2d')!;
    for (let y = 0; y < mapHeight; y++) {
      for (let x = 0; x < mapWidth; x++) {
        const raw = mapRes.tiles[y * mapWidth + x];
        const tileId = tileIdFromRaw(raw);
        const { sx, sy } = spriteCoords(tileId);
        offCtx.drawImage(sheet, sx, sy, TILE_SIZE, TILE_SIZE, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      }
    }

    // Scale to thumbnail
    canvas.width = el.clientWidth * 2;
    canvas.height = el.clientHeight * 2;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    const ctx = canvas.getContext('2d')!;
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(offscreen, 0, 0, canvas.width, canvas.height);
    el.appendChild(canvas);
  }

  // Use IntersectionObserver for lazy loading
  const observer = new IntersectionObserver((entries) => {
    for (const entry of entries) {
      if (entry.isIntersecting) {
        observer.unobserve(entry.target);
        renderThumbnail(entry.target as HTMLElement);
      }
    }
  }, { rootMargin: '200px' });

  document.querySelectorAll('.card-thumb').forEach(el => observer.observe(el));
</script>

<style>
.hero { text-align: center; padding: 2rem 0 1.5rem; }
.hero-sub { color: var(--text-muted); font-size: 1.1rem; }

.gallery-header { margin-bottom: 1.5rem; }
.sort-row { display: flex; justify-content: space-between; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
.sort-tabs { display: flex; gap: 0.5rem; }
.sort-tabs a {
  padding: 0.4rem 1rem;
  border-radius: 6px;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 0.875rem;
}
.sort-tabs a.active { background: var(--accent); color: white; border-color: var(--accent); }
.poll-status { color: var(--text-muted); font-size: 0.75rem; opacity: 0.7; }
.city-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 1rem; }
.empty { color: var(--text-muted); text-align: center; padding: 3rem; }

.cta-footer { text-align: center; padding: 2.5rem 0 1rem; }
.cta-link {
  display: inline-block;
  padding: 0.6rem 1.5rem;
  background: var(--accent);
  color: white;
  border-radius: 999px;
  font-weight: 600;
  font-size: 1rem;
  transition: background 0.15s;
}
.cta-link:hover { background: var(--accent-hover); color: white; }

@media (max-width: 480px) {
  .hero h1 { font-size: 1.5rem; }
  .sort-tabs a { padding: 0.35rem 0.75rem; font-size: 0.8125rem; }
}
</style>
